diff --git a/node_modules/@minchat/react/dist/index.js b/node_modules/@minchat/react/dist/index.js
index eb241d9..6046afa 100644
--- a/node_modules/@minchat/react/dist/index.js
+++ b/node_modules/@minchat/react/dist/index.js
@@ -1,8 +1,8 @@
 
 'use strict'
 
-if (process.env.NODE_ENV === 'production') {
-  module.exports = require('./react.cjs.production.min.js')
-} else {
+// if (process.env.NODE_ENV === 'production') {
+//   module.exports = require('./react.cjs.production.min.js')
+// } else {
   module.exports = require('./react.cjs.development.js')
-}
+// }
diff --git a/node_modules/@minchat/react/dist/react.cjs.development.js b/node_modules/@minchat/react/dist/react.cjs.development.js
index 23e78ef..531ccce 100644
--- a/node_modules/@minchat/react/dist/react.cjs.development.js
+++ b/node_modules/@minchat/react/dist/react.cjs.development.js
@@ -1,666 +1 @@
-'use strict';
-
-Object.defineProperty(exports, '__esModule', { value: true });
-
-function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
-
-var React = require('react');
-var React__default = _interopDefault(React);
-var MinChatJs = _interopDefault(require('@minchat/js'));
-
-var MinChatContext = /*#__PURE__*/React.createContext({
-  updateChatOrder: 0,
-  setUpdateChatOrder: () => {},
-  setChats: () => {}
-});
-
-/**
- * get the user object thats attached to the minchat object
- * @returns
- */
-
-const useUser = () => {
-  const {
-    user
-  } = React.useContext(MinChatContext);
-  return user;
-};
-
-/**
- *
- * @param chat - the chat object to get messages for
- * @param reverse - whether to reverse the order of the messages
- * @returns
- */
-
-const useMessages = (chat, reverse) => {
-  const [messages, setMessages] = React.useState();
-  /*<Array<{ userId: string, text: string }>>*/
-
-  const [loading, setLoading] = React.useState(true);
-  const [error, setError] = React.useState();
-  const [paginateLoading, setPaginateLoading] = React.useState(true);
-  const user = useUser();
-  const {
-    setUpdateChatOrder,
-    setChats,
-    chats,
-    setOnChatNewChat
-  } = React.useContext(MinChatContext);
-  const [paginationCount, setPaginationCount] = React.useState(1); //keeps track of which pages have already been inserted into the chats state
-
-  const [pagesInserted, setPagesInserted] = React.useState([]);
-  React.useEffect(() => {
-    //find the exact channel in the chats array and update its information because the messages have been successfully retrieved
-    //which means the chat objects channel Id has be updated and can be found in the chats array
-    if (chats && messages && chat) {
-      //
-      setChats(currentChats => {
-        if (!currentChats) return [];
-        return currentChats.map(chatItem => {
-          if (chatItem.getId() === chat.getId()) {
-            //determine whether to set the group name to the chats object chat or to the local chat object
-            if (chat.getTitle() !== "Group Chat") {
-              chatItem.setTitle(chat.getTitle());
-            } else {
-              chat.setTitle(chatItem.getTitle());
-            }
-          }
-
-          return chatItem;
-        });
-      }); //update the seen for all the messages that are not seen
-
-      for (const message of messages) {
-        if (!message.seen && user && message.user.id !== user.id) {
-          chat.jsChat.setSeen(message.id);
-        }
-      }
-    }
-  }, [messages]);
-  React.useEffect(() => {
-    //the paginationCount has been reset because the chat object has changed so query first page of messages
-    if (paginationCount == 1 && pagesInserted.length == 0) {
-      //query messages of new chat object
-      paginate();
-    }
-  }, [paginationCount, pagesInserted]);
-  React.useEffect(() => {
-    setPaginationCount(1);
-    setPagesInserted([]);
-
-    if (chat) {
-      //the chat object has changed so clear the list of messages of the previous chat object and start loading to query new messages
-      setMessages(undefined);
-      setLoading(true);
-      setPaginateLoading(true);
-      /**
-       *
-       */
-
-      chat.jsChat.onMessageSeen(messageId => {
-        setMessages(messagesValue => {
-          if (!messagesValue) return messagesValue;
-          const newMessages = messagesValue.map(message => {
-            if (messageId === message.id) {
-              return { ...message,
-                seen: true
-              };
-            } else {
-              return message;
-            }
-          });
-          return newMessages;
-        });
-      });
-      /**
-       *
-       */
-
-      chat.jsChat.onMessage(message => {
-        /** a new message has been received */
-        if (message) {
-          addNewMessage(message);
-          setUpdateChatOrder(val => val + 1);
-        } else {
-          console.log("error");
-        }
-      });
-      chat.jsChat.onError(error => {
-        setError(error);
-      });
-    }
-
-    return () => {
-      if (chat) {
-        chat.release();
-      }
-    };
-  }, [chat]);
-  /**
-   * add a new message to the messages array
-   */
-
-  const addNewMessage = message => {
-    setMessages(existingData => {
-      const newMessages = existingData ? [...existingData] : [];
-
-      if (reverse) {
-        newMessages.unshift(message);
-      } else {
-        newMessages.push(message);
-      }
-
-      return newMessages;
-    });
-  };
-  /**
-   *
-   */
-
-
-  const paginate = async () => {
-    setPaginateLoading(true);
-    setError(undefined);
-    let messageResponse = null;
-
-    if (chat) {
-      messageResponse = await chat.jsChat.getMessages(paginationCount);
-    }
-
-    setPaginationCount(count => count + 1); //todo handle when its an error response
-
-    if (messageResponse && !pagesInserted.includes(messageResponse.page)) {
-      //add the current page to the list of included pages already
-      setPagesInserted(currentPagesInserted => {
-        if (messageResponse) {
-          currentPagesInserted.push(messageResponse.page);
-        }
-
-        return currentPagesInserted;
-      }); //add chats to the end of the chats list
-
-      setMessages(currentMessages => {
-        // clean up the current messages by replacing any temporary messages
-        const newCurrentMessages = currentMessages && currentMessages.map(message => {
-          if (message.metadata && message.metadata.replacedWithServerData && messageResponse) {
-            // go through all the server messages to determine which one needs to be replaced onto the local messages
-            for (const serverMessage of messageResponse.messages) {
-              if ((serverMessage.metadata && serverMessage.metadata.minchatMessageIdentifier) === message.metadata.minchatMessageIdentifier) {
-                return serverMessage;
-              }
-            }
-          }
-
-          return message;
-        });
-        const currentMessagesSet = new Set(newCurrentMessages && newCurrentMessages.map(({
-          id
-        }) => id)); //do not add a message that already exists in the messages array
-
-        const messagesResponseArray = messageResponse && messageResponse.messages.filter(message => !currentMessagesSet.has(message.id)); // TODO do the messages need to be ordered by date?
-
-        if (messagesResponseArray) {
-          if (newCurrentMessages) {
-            if (reverse) {
-              return [...newCurrentMessages, ...messagesResponseArray.reverse()];
-            } else {
-              return [...messagesResponseArray, ...newCurrentMessages];
-            }
-          } else {
-            if (reverse) {
-              return messagesResponseArray.reverse();
-            } else {
-              return messagesResponseArray;
-            }
-          }
-        } else {
-          return newCurrentMessages;
-        }
-      });
-      setLoading(false);
-    }
-
-    setPaginateLoading(false);
-  };
-  /**
-  *
-  * @param param0
-  * @param callback - callback function to know the status of the message being sent whether it was successful or there was an error
-  */
-
-
-  const sendMessage = (message, callback) => {
-    if (chat) {
-      setOnChatNewChat && setOnChatNewChat(chat);
-      const dateObj = new Date();
-      const dateCreated = dateObj.toISOString();
-      const meta = message.metadata ? message.metadata : {};
-      meta.minchatMessageIdentifier = dateCreated;
-
-      if (user) {
-        addNewMessage({
-          text: message.text,
-          user: user,
-          loading: true,
-          createdAt: dateObj,
-          id: dateCreated,
-          metadata: { ...meta,
-            replacedWithServerData: "true"
-          }
-        });
-      }
-
-      chat.jsChat.sendMessage({ ...message,
-        metadata: meta
-      }, data => {
-        //find and replace the message that has the same created_at value as the one thats returned in the data object
-        if (data) {
-          setMessages(messagesValue => {
-            if (!messagesValue) return messagesValue;
-            const newMessages = messagesValue.map(message => {
-              if ((message.metadata && message.metadata.minchatMessageIdentifier) === dateCreated) {
-                return data;
-              } else {
-                return message;
-              }
-            });
-            return newMessages;
-          });
-        } //execute the callback function
-
-
-        if (callback) {
-          callback(data);
-        }
-      });
-      setUpdateChatOrder(val => val + 1);
-    }
-  };
-
-  return {
-    messages,
-    loading,
-    error,
-    paginate,
-    sendMessage,
-    paginateLoading
-  };
-};
-
-class Chat {
-  constructor(jsChat) {
-    this.jsChat = jsChat;
-  }
-
-  release() {
-    this.jsChat.release();
-  }
-
-  getChatAvatar() {
-    return this.jsChat.getChatAvatar();
-  }
-
-  getId() {
-    return this.jsChat.getId();
-  }
-
-  getTitle() {
-    return this.jsChat.getTitle();
-  }
-
-  setTitle(title) {
-    return this.jsChat.setTitle(title);
-  }
-
-  getLastMessage() {
-    return this.jsChat.getLastMessage();
-  }
-
-  getMembers() {
-    return this.jsChat.getMembers();
-  }
-
-  getMemberIds() {
-    return this.jsChat.getMemberIds();
-  }
-
-  getMetadata() {
-    return this.jsChat.getMetadata();
-  }
-
-  async setMetaData(metadata) {
-    return this.jsChat.setMetaData(metadata);
-  }
-
-  onTypingStopped(listener) {
-    return this.jsChat.onTypingStopped(listener);
-  }
-
-  onTypingStarted(listener) {
-    return this.jsChat.onTypingStarted(listener);
-  }
-
-  async onMemberStatusChanged(listener) {
-    return this.jsChat.onMemberStatusChanged(listener);
-  }
-
-  async startTyping() {
-    return this.jsChat.startTyping();
-  }
-
-  async stopTyping() {
-    return this.jsChat.stopTyping();
-  }
-
-  setSeen(messageId) {
-    return this.jsChat.setSeen(messageId);
-  }
-
-}
-
-/**
- * hook to get the chatbunny instance
- */
-
-const useMinChat = () => {
-  const {
-    minChat
-  } = React.useContext(MinChatContext);
-  return minChat;
-};
-
-const useChats = () => {
-  const [loading, setLoading] = React.useState(true);
-  const [error, setError] = React.useState();
-  const [paginateLoading, setPaginateLoading] = React.useState(true); //keeps track of which pages have already been inserted into the chats state
-
-  const [pagesInserted, setPagesInserted] = React.useState([]);
-  const [paginationCount, setPaginationCount] = React.useState(1);
-  const {
-    updateChatOrder,
-    chats,
-    setChats,
-    onMessage,
-    onChatNewChat,
-    setOnChatNewChat
-  } = React.useContext(MinChatContext); //** keeps track o how many times the chats get ordered */
-
-  const [chatsOrdered, setChatsOrdered] = React.useState(0);
-  const minChat = useMinChat();
-  const user = useUser();
-  React.useEffect(() => {
-    if (chats && onChatNewChat) {
-      sendToContextOnMessageListener(onChatNewChat.getLastMessage());
-      setChats(currentChats => {
-        const chatExists = chats.find(chat => chat.getId() === onChatNewChat.getId());
-        let updatedChats;
-
-        if (chatExists) {
-          // chat exists so just replace the chat object
-          updatedChats = currentChats ? currentChats.map(chat => chat.getId() === onChatNewChat.getId() ? onChatNewChat : chat) : currentChats;
-        } else {
-          // chat doesnt exist so add a new chat
-          updatedChats = currentChats ? [onChatNewChat, ...currentChats] : [onChatNewChat];
-        }
-
-        return updatedChats ? orderChats(updatedChats) : updatedChats;
-      });
-    }
-  }, [onChatNewChat]);
-
-  const orderChats = chats => {
-    return chats.sort((a, b) => {
-      let aTime = null;
-      let bTime = null;
-
-      if (a.jsChat.config.lastMessage) {
-        aTime = a.jsChat.config.lastMessage.createdAt;
-      }
-
-      if (b.jsChat.config.lastMessage) {
-        bTime = b.jsChat.config.lastMessage.createdAt;
-      }
-
-      if (aTime && bTime) {
-        const aDate = new Date(aTime);
-        const bDate = new Date(bTime);
-        return bDate.getTime() - aDate.getTime();
-      } else {
-        return 0;
-      }
-    });
-  };
-
-  React.useEffect(() => {
-    // order the chats by the time of each chat's last sent message
-    if (chats) {
-      setChats(currentChats => currentChats ? orderChats(currentChats) : undefined);
-      setChatsOrdered(count => count + 1);
-    }
-  }, [chats, updateChatOrder]);
-  React.useEffect(() => {
-    if (minChat && user) {
-      // only query the chats when the minchat object thats in the MinChatContext has been assigned with config properties
-      paginate(); //add onChat listener
-
-      minChat.instance.onChat(jsChat => {
-        const reactChat = new Chat(jsChat);
-        setOnChatNewChat && setOnChatNewChat(reactChat);
-      });
-    }
-  }, [minChat, user]);
-  /**
-   *
-   * @param chat the chat that the message was sent in
-   */
-
-  const sendToContextOnMessageListener = message => {
-    //dont execute the listener if the message was sent by the current user
-    if (message && message.user.id !== (user && user.id)) {
-      onMessage && onMessage(message);
-    }
-  };
-
-  const paginate = async () => {
-    if (minChat) {
-      setPaginateLoading(true);
-      setError(undefined);
-      const jsChatsList = await minChat.instance.getChats(paginationCount);
-      setPaginationCount(count => count + 1);
-
-      if (!pagesInserted.includes(jsChatsList.page)) {
-        //add the current page to the list of included pages already
-        setPagesInserted(currentPagesInserted => {
-          currentPagesInserted.push(jsChatsList.page);
-          return currentPagesInserted;
-        });
-        const reactChats = jsChatsList.chats.map(jsChat => new Chat(jsChat)); //todo handle when its an error response
-        //add chats to the end of the chats list
-
-        setChats(currentChats => {
-          if (currentChats) {
-            return [...reactChats, ...currentChats];
-          } else {
-            return reactChats;
-          }
-        });
-        setPaginateLoading(false);
-        setLoading(false);
-      }
-    }
-  };
-
-  return {
-    chats,
-    loading,
-    error,
-    paginate,
-    paginateLoading,
-    chatsOrdered
-  };
-};
-
-class MinChat {
-  static getInstance(MINCHAT_API_KEY) {
-    return new MinChatInstanceReact(MINCHAT_API_KEY);
-  }
-
-}
-
-class MinChatInstanceReact {
-  constructor(MINCHAT_API_KEY) {
-    /**
-     *  stores any created chat when starting a new chat to avoid recreating the chat over and over
-     * Key is the id of the user you are chatting with
-     * value is the chat object
-     * */
-    //chats json variable with index types of string and value types of Chat
-    this.chats = {};
-
-    this.getConnectedUser = () => {
-      return this.instance.getConnectedUser();
-    };
-
-    this.instance = MinChatJs.getInstance(MINCHAT_API_KEY);
-  }
-
-  init(configurations) {
-    this.instance.init(configurations);
-    return this;
-  }
-
-  async createUser(user) {
-    return await this.instance.createUser(user);
-  }
-
-  async fetchUser(username) {
-    return await this.instance.fetchUser(username);
-  }
-
-  async fetchUserById(id) {
-    return await this.instance.fetchUserById(id);
-  }
-
-  async updateUserById(userId, user) {
-    return await this.instance.updateUserById(userId, user);
-  }
-
-  async connectUser(user) {
-    await this.instance.connectUser(user);
-    return this;
-  }
-
-  async chat(withUsername, options) {
-    //check if the chat already exists in the chats json object
-    if (this.chats[withUsername]) {
-      const foundChat = this.chats[withUsername];
-      return foundChat;
-    } else {
-      const jsChat = await this.instance.chat(withUsername, options);
-      let chat = null;
-
-      if (jsChat) {
-        chat = new Chat(jsChat);
-        this.chats[withUsername] = chat;
-      }
-
-      return chat;
-    }
-  }
-
-  async groupChat(params) {
-    //put the id's of the users in the group chat into a string array
-    // const ids = params.members.map(member => member.id)
-    //sort the array
-    // ids.sort()
-    //join the array into a string
-    // const joinedId = ids.join("-")
-    //check if the chat already exists in the chats json object
-    // if (this.chats[joinedId]) {
-    //     //the chat was already created, so just update any information if necessary
-    //     const alreadyExistingChat = this.chats[joinedId]
-    //     if (params.name && params.name.trim().length > 0) {
-    //         alreadyExistingChat.setName(params.name.trim())
-    //         this.chats[joinedId] = alreadyExistingChat
-    //     }
-    //     return alreadyExistingChat
-    // } else {
-    const jsChat = await this.instance.groupChat(params);
-    let chat = null;
-
-    if (jsChat) {
-      chat = new Chat(jsChat);
-    } // this.chats[joinedId] = chat
-
-
-    return chat; // }
-  }
-
-}
-
-function MinChatProvider({
-  apiKey,
-  children,
-  user,
-  demo = false,
-  test = false,
-  socketOptions,
-  onMessage
-}) {
-  const [minchat, setMinchat] = React.useState(); // is called to reorder the chats array when a new message is sent or recieved 
-
-  const [updateChatOrder, setUpdateChatOrder] = React.useState(0);
-  const [chats, setChats] = React.useState(); //keeps track of the chat objects (conversations)
-
-  const [onChatNewChat, setOnChatNewChat] = React.useState();
-  /**
-   * this is the user thats stored in the MinChat context
-  */
-
-  const [contextUser, setContextUser] = React.useState();
-  React.useEffect(() => {
-    const setupMinChat = async () => {
-      const instance = MinChat.getInstance(apiKey).init({
-        test,
-        demo,
-        socketOptions
-      });
-      setMinchat(instance);
-    };
-
-    setupMinChat();
-  }, []);
-  React.useEffect(() => {
-    if (minchat && user) {
-      const updateConnectedUser = async () => {
-        await minchat.connectUser(user);
-        setContextUser(minchat.instance.getConnectedUser());
-      };
-
-      updateConnectedUser();
-    }
-  }, [user, minchat]);
-  return React__default.createElement(MinChatContext.Provider, {
-    value: {
-      minChat: minchat,
-      updateChatOrder,
-      setUpdateChatOrder,
-      chats,
-      setChats,
-      onMessage,
-      user: contextUser,
-      onChatNewChat,
-      setOnChatNewChat
-    }
-  }, children);
-}
-
-exports.Chat = Chat;
-exports.MinChatProvider = MinChatProvider;
-exports.default = MinChat;
-exports.useChats = useChats;
-exports.useMessages = useMessages;
-exports.useMinChat = useMinChat;
-exports.useUser = useUser;
-//# sourceMappingURL=react.cjs.development.js.map
+"use strict";function _interopDefault(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var React=require("react"),React__default=_interopDefault(React),MinChatJs=_interopDefault(require("@minchat/js")),MinChatContext=React.createContext({updateChatOrder:0,setUpdateChatOrder:()=>{},setChats:()=>{}});const useUser=()=>{const{user:t}=React.useContext(MinChatContext);return t},useMessages=(t,e)=>{const[a,s]=React.useState(),[n,r]=React.useState(!0),[i,c]=React.useState(),[h,u]=React.useState(!0),o=useUser(),{setUpdateChatOrder:C,setChats:d,chats:g,setOnChatNewChat:p}=React.useContext(MinChatContext),[f,l]=React.useState(1),[M,m]=React.useState([]);React.useEffect((()=>{if(g&&a&&t){d((e=>e?e.map((e=>(e.getId()===t.getId()&&("Group Chat"!==t.getTitle()?e.setTitle(t.getTitle()):t.setTitle(e.getTitle())),e))):[]));for(const e of a)!e.seen&&o&&e.user.id!==o.id&&t.jsChat.setSeen(e.id)}}),[a]),React.useEffect((()=>{1==f&&0==M.length&&S()}),[f,M]),React.useEffect((()=>(l(1),m([]),t&&(s(void 0),r(!0),u(!0),t.jsChat.onMessageSeen((t=>{s((e=>{if(!e)return e;return e.map((e=>t===e.id?{...e,seen:!0}:e))}))})),t.jsChat.onMessage((t=>{t?(R(t),C((t=>t+1))):console.log("error")})),t.jsChat.onError((t=>{c(t)}))),()=>{t&&t.release()})),[t]);const R=t=>{s((a=>{const s=a?[...a]:[];return e?s.unshift(t):s.push(t),s}))},S=async()=>{u(!0),c(void 0);let a=null;t&&(a=await t.jsChat.getMessages(f)),l((t=>t+1)),a&&!M.includes(a.page)&&(m((t=>(a&&t.push(a.page),t))),s((t=>{const s=t&&t.map((t=>{if(t.metadata&&t.metadata.replacedWithServerData&&a)for(const e of a.messages)if((e.metadata&&e.metadata.minchatMessageIdentifier)===t.metadata.minchatMessageIdentifier)return e;return t})),n=new Set(s&&s.map((({id:t})=>t))),r=a&&a.messages.filter((t=>!n.has(t.id)));return r?s?e?[...s,...r.reverse()]:[...r,...s]:e?r.reverse():r:s})),r(!1)),u(!1)};return{messages:a,loading:n,error:i,paginate:S,sendMessage:(e,a)=>{if(t){p&&p(t);const n=new Date,r=n.toISOString(),i=e.metadata?e.metadata:{};i.minchatMessageIdentifier=r,o&&R({text:e.text,user:o,loading:!0,createdAt:n,id:r,metadata:{...i,replacedWithServerData:"true"}}),t.jsChat.sendMessage({...e,metadata:i},(t=>{t&&s((e=>{if(!e)return e;const a=e.map((e=>(e.metadata&&e.metadata.minchatMessageIdentifier)===r?t:e));return a})),a&&a(t)})),C((t=>t+1))}},paginateLoading:h}};class Chat{constructor(t){this.jsChat=t}release(){this.jsChat.release()}getChatAvatar(){return this.jsChat.getChatAvatar()}getId(){return this.jsChat.getId()}getTitle(){return this.jsChat.getTitle()}setTitle(t){return this.jsChat.setTitle(t)}getLastMessage(){return this.jsChat.getLastMessage()}getMembers(){return this.jsChat.getMembers()}getMemberIds(){return this.jsChat.getMemberIds()}getMetadata(){return this.jsChat.getMetadata()}async setMetaData(t){return this.jsChat.setMetaData(t)}onTypingStopped(t){return this.jsChat.onTypingStopped(t)}onTypingStarted(t){return this.jsChat.onTypingStarted(t)}async onMemberStatusChanged(t){return this.jsChat.onMemberStatusChanged(t)}async startTyping(){return this.jsChat.startTyping()}async stopTyping(){return this.jsChat.stopTyping()}setSeen(t){return this.jsChat.setSeen(t)}}const useMinChat=()=>{const{minChat:t}=React.useContext(MinChatContext);return t},useChats=()=>{const[t,e]=React.useState(!0),[a,s]=React.useState(),[n,r]=React.useState(!0),[i,c]=React.useState([]),[h,u]=React.useState(1),{updateChatOrder:o,chats:C,setChats:d,onMessage:g,onChatNewChat:p,setOnChatNewChat:f}=React.useContext(MinChatContext),[l,M]=React.useState(0),m=useMinChat(),R=useUser();React.useEffect((()=>{C&&p&&(y(p.getLastMessage()),d((t=>{let e;return e=C.find((t=>t.getId()===p.getId()))?t?t.map((t=>t.getId()===p.getId()?p:t)):t:t?[p,...t]:[p],e?S(e):e})))}),[p]);const S=t=>t.sort(((t,e)=>{let a=null,s=null;if(t.jsChat.config.lastMessage&&(a=t.jsChat.config.lastMessage.createdAt),e.jsChat.config.lastMessage&&(s=e.jsChat.config.lastMessage.createdAt),a&&s){const t=new Date(a);return new Date(s).getTime()-t.getTime()}return 0}));React.useEffect((()=>{C&&(d((t=>t?S(t):void 0)),M((t=>t+1)))}),[C,o]),React.useEffect((()=>{m&&R&&(j(),m.instance.onChat((t=>{const e=new Chat(t);f&&f(e)})))}),[m,R]);const y=t=>{t&&t.user.id!==(R&&R.id)&&g&&g(t)},j=async()=>{if(m){r(!0),s(void 0);const t=await m.instance.getChats(1);if(u(1),!i.includes(t.page)){c((e=>(e.push(t.page),e)));const a=t.chats.map((t=>new Chat(t)));d(a),r(!1),e(!1)}}};return{chats:C,loading:t,error:a,paginate:async()=>{if(m){r(!0),s(void 0);const t=await m.instance.getChats(h);if(u((t=>t+1)),!i.includes(t.page)){c((e=>(e.push(t.page),e)));const a=t.chats.map((t=>new Chat(t)));d((t=>t?[...a,...t]:a)),r(!1),e(!1)}}},paginateLoading:n,chatsOrdered:l}};class MinChat{static getInstance(t){return new MinChatInstanceReact(t)}}class MinChatInstanceReact{constructor(t){this.chats={},this.getConnectedUser=()=>this.instance.getConnectedUser(),this.instance=MinChatJs.getInstance(t)}init(t){return this.instance.init(t),this}async createUser(t){return await this.instance.createUser(t)}async fetchUser(t){return await this.instance.fetchUser(t)}async fetchUserById(t){return await this.instance.fetchUserById(t)}async updateUserById(t,e){return await this.instance.updateUserById(t,e)}async connectUser(t){return await this.instance.connectUser(t),this}async chat(t,e){if(this.chats[t]){return this.chats[t]}{const a=await this.instance.chat(t,e);let s=null;return a&&(s=new Chat(a),this.chats[t]=s),s}}async groupChat(t){const e=await this.instance.groupChat(t);let a=null;return e&&(a=new Chat(e)),a}}function MinChatProvider({apiKey:t,children:e,user:a,demo:s=!1,test:n=!1,socketOptions:r,onMessage:i}){const[c,h]=React.useState(),[u,o]=React.useState(0),[C,d]=React.useState(),[g,p]=React.useState(),[f,l]=React.useState();return React.useEffect((()=>{(async()=>{const e=MinChat.getInstance(t).init({test:n,demo:s,socketOptions:r});h(e)})()}),[]),React.useEffect((()=>{if(c&&a){(async()=>{await c.connectUser(a),l(c.instance.getConnectedUser())})()}}),[a,c]),React__default.createElement(MinChatContext.Provider,{value:{minChat:c,updateChatOrder:u,setUpdateChatOrder:o,chats:C,setChats:d,onMessage:i,user:f,onChatNewChat:g,setOnChatNewChat:p}},e)}exports.Chat=Chat,exports.MinChatProvider=MinChatProvider,exports.default=MinChat,exports.useChats=useChats,exports.useMessages=useMessages,exports.useMinChat=useMinChat,exports.useUser=useUser;
\ No newline at end of file
diff --git a/node_modules/@minchat/react/dist/react.cjs.production.min.js b/node_modules/@minchat/react/dist/react.cjs.production.min.js
index 2107916..a8ef18b 100644
--- a/node_modules/@minchat/react/dist/react.cjs.production.min.js
+++ b/node_modules/@minchat/react/dist/react.cjs.production.min.js
@@ -1,2 +1,287 @@
-"use strict";function t(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react"),s=t(e),a=t(require("@minchat/js")),n=e.createContext({updateChatOrder:0,setUpdateChatOrder:()=>{},setChats:()=>{}});const r=()=>{const{user:t}=e.useContext(n);return t};class i{constructor(t){this.jsChat=t}release(){this.jsChat.release()}getChatAvatar(){return this.jsChat.getChatAvatar()}getId(){return this.jsChat.getId()}getTitle(){return this.jsChat.getTitle()}setTitle(t){return this.jsChat.setTitle(t)}getLastMessage(){return this.jsChat.getLastMessage()}getMembers(){return this.jsChat.getMembers()}getMemberIds(){return this.jsChat.getMemberIds()}getMetadata(){return this.jsChat.getMetadata()}async setMetaData(t){return this.jsChat.setMetaData(t)}onTypingStopped(t){return this.jsChat.onTypingStopped(t)}onTypingStarted(t){return this.jsChat.onTypingStarted(t)}async onMemberStatusChanged(t){return this.jsChat.onMemberStatusChanged(t)}async startTyping(){return this.jsChat.startTyping()}async stopTyping(){return this.jsChat.stopTyping()}setSeen(t){return this.jsChat.setSeen(t)}}const h=()=>{const{minChat:t}=e.useContext(n);return t};class c{static getInstance(t){return new u(t)}}class u{constructor(t){this.chats={},this.getConnectedUser=()=>this.instance.getConnectedUser(),this.instance=a.getInstance(t)}init(t){return this.instance.init(t),this}async createUser(t){return await this.instance.createUser(t)}async fetchUser(t){return await this.instance.fetchUser(t)}async fetchUserById(t){return await this.instance.fetchUserById(t)}async updateUserById(t,e){return await this.instance.updateUserById(t,e)}async connectUser(t){return await this.instance.connectUser(t),this}async chat(t,e){if(this.chats[t])return this.chats[t];{const s=await this.instance.chat(t,e);let a=null;return s&&(a=new i(s),this.chats[t]=a),a}}async groupChat(t){const e=await this.instance.groupChat(t);let s=null;return e&&(s=new i(e)),s}}exports.Chat=i,exports.MinChatProvider=function({apiKey:t,children:a,user:r,demo:i=!1,test:h=!1,socketOptions:u,onMessage:o}){const[d,g]=e.useState(),[C,p]=e.useState(0),[l,f]=e.useState(),[m,M]=e.useState(),[S,j]=e.useState();return e.useEffect(()=>{(async()=>{const e=c.getInstance(t).init({test:h,demo:i,socketOptions:u});g(e)})()},[]),e.useEffect(()=>{d&&r&&(async()=>{await d.connectUser(r),j(d.instance.getConnectedUser())})()},[r,d]),s.createElement(n.Provider,{value:{minChat:d,updateChatOrder:C,setUpdateChatOrder:p,chats:l,setChats:f,onMessage:o,user:S,onChatNewChat:m,setOnChatNewChat:M}},a)},exports.default=c,exports.useChats=()=>{const[t,s]=e.useState(!0),[a,c]=e.useState(),[u,o]=e.useState(!0),[d,g]=e.useState([]),[C,p]=e.useState(1),{updateChatOrder:l,chats:f,setChats:m,onMessage:M,onChatNewChat:S,setOnChatNewChat:j}=e.useContext(n),[y,w]=e.useState(0),I=h(),T=r();e.useEffect(()=>{f&&S&&(v(S.getLastMessage()),m(t=>{let e;return e=f.find(t=>t.getId()===S.getId())?t?t.map(t=>t.getId()===S.getId()?S:t):t:t?[S,...t]:[S],e?U(e):e}))},[S]);const U=t=>t.sort((t,e)=>{let s=null,a=null;if(t.jsChat.config.lastMessage&&(s=t.jsChat.config.lastMessage.createdAt),e.jsChat.config.lastMessage&&(a=e.jsChat.config.lastMessage.createdAt),s&&a){const t=new Date(s);return new Date(a).getTime()-t.getTime()}return 0});e.useEffect(()=>{f&&(m(t=>t?U(t):void 0),w(t=>t+1))},[f,l]),e.useEffect(()=>{I&&T&&(x(),I.instance.onChat(t=>{const e=new i(t);j&&j(e)}))},[I,T]);const v=t=>{t&&t.user.id!==(T&&T.id)&&M&&M(t)},x=async()=>{if(I){o(!0),c(void 0);const t=await I.instance.getChats(C);if(p(t=>t+1),!d.includes(t.page)){g(e=>(e.push(t.page),e));const e=t.chats.map(t=>new i(t));m(t=>t?[...e,...t]:e),o(!1),s(!1)}}};return{chats:f,loading:t,error:a,paginate:x,paginateLoading:u,chatsOrdered:y}},exports.useMessages=(t,s)=>{const[a,i]=e.useState(),[h,c]=e.useState(!0),[u,o]=e.useState(),[d,g]=e.useState(!0),C=r(),{setUpdateChatOrder:p,setChats:l,chats:f,setOnChatNewChat:m}=e.useContext(n),[M,S]=e.useState(1),[j,y]=e.useState([]);e.useEffect(()=>{if(f&&a&&t){l(e=>e?e.map(e=>(e.getId()===t.getId()&&("Group Chat"!==t.getTitle()?e.setTitle(t.getTitle()):t.setTitle(e.getTitle())),e)):[]);for(const e of a)!e.seen&&C&&e.user.id!==C.id&&t.jsChat.setSeen(e.id)}},[a]),e.useEffect(()=>{1==M&&0==j.length&&I()},[M,j]),e.useEffect(()=>(S(1),y([]),t&&(i(void 0),c(!0),g(!0),t.jsChat.onMessageSeen(t=>{i(e=>e?e.map(e=>t===e.id?{...e,seen:!0}:e):e)}),t.jsChat.onMessage(t=>{t?(w(t),p(t=>t+1)):console.log("error")}),t.jsChat.onError(t=>{o(t)})),()=>{t&&t.release()}),[t]);const w=t=>{i(e=>{const a=e?[...e]:[];return s?a.unshift(t):a.push(t),a})},I=async()=>{g(!0),o(void 0);let e=null;t&&(e=await t.jsChat.getMessages(M)),S(t=>t+1),e&&!j.includes(e.page)&&(y(t=>(e&&t.push(e.page),t)),i(t=>{const a=t&&t.map(t=>{if(t.metadata&&t.metadata.replacedWithServerData&&e)for(const s of e.messages)if((s.metadata&&s.metadata.minchatMessageIdentifier)===t.metadata.minchatMessageIdentifier)return s;return t}),n=new Set(a&&a.map(({id:t})=>t)),r=e&&e.messages.filter(t=>!n.has(t.id));return r?a?s?[...a,...r.reverse()]:[...r,...a]:s?r.reverse():r:a}),c(!1)),g(!1)};return{messages:a,loading:h,error:u,paginate:I,sendMessage:(e,s)=>{if(t){m&&m(t);const a=new Date,n=a.toISOString(),r=e.metadata?e.metadata:{};r.minchatMessageIdentifier=n,C&&w({text:e.text,user:C,loading:!0,createdAt:a,id:n,metadata:{...r,replacedWithServerData:"true"}}),t.jsChat.sendMessage({...e,metadata:r},t=>{t&&i(e=>e?e.map(e=>(e.metadata&&e.metadata.minchatMessageIdentifier)===n?t:e):e),s&&s(t)}),p(t=>t+1)}},paginateLoading:d}},exports.useMinChat=h,exports.useUser=r;
+"use strict";
+function t(t) {
+    return t && "object" == typeof t && "default" in t ? t.default : t;
+}
+Object.defineProperty(exports, "__esModule", { value: !0 });
+var e = require("react"),
+    s = t(e),
+    a = t(require("@minchat/js")),
+    n = e.createContext({ updateChatOrder: 0, setUpdateChatOrder: () => {}, setChats: () => {} });
+const r = () => {
+    const { user: t } = e.useContext(n);
+    return t;
+};
+class i {
+    constructor(t) {
+        this.jsChat = t;
+    }
+    release() {
+        this.jsChat.release();
+    }
+    getChatAvatar() {
+        return this.jsChat.getChatAvatar();
+    }
+    getId() {
+        return this.jsChat.getId();
+    }
+    getTitle() {
+        return this.jsChat.getTitle();
+    }
+    setTitle(t) {
+        return this.jsChat.setTitle(t);
+    }
+    getLastMessage() {
+        return this.jsChat.getLastMessage();
+    }
+    getMembers() {
+        return this.jsChat.getMembers();
+    }
+    getMemberIds() {
+        return this.jsChat.getMemberIds();
+    }
+    getMetadata() {
+        return this.jsChat.getMetadata();
+    }
+    async setMetaData(t) {
+        return this.jsChat.setMetaData(t);
+    }
+    onTypingStopped(t) {
+        return this.jsChat.onTypingStopped(t);
+    }
+    onTypingStarted(t) {
+        return this.jsChat.onTypingStarted(t);
+    }
+    async onMemberStatusChanged(t) {
+        return this.jsChat.onMemberStatusChanged(t);
+    }
+    async startTyping() {
+        return this.jsChat.startTyping();
+    }
+    async stopTyping() {
+        return this.jsChat.stopTyping();
+    }
+    setSeen(t) {
+        return this.jsChat.setSeen(t);
+    }
+}
+const h = () => {
+    const { minChat: t } = e.useContext(n);
+    return t;
+};
+class c {
+    static getInstance(t) {
+        return new u(t);
+    }
+}
+class u {
+    constructor(t) {
+        (this.chats = {}), (this.getConnectedUser = () => this.instance.getConnectedUser()), (this.instance = a.getInstance(t));
+    }
+    init(t) {
+        return this.instance.init(t), this;
+    }
+    async createUser(t) {
+        return await this.instance.createUser(t);
+    }
+    async fetchUser(t) {
+        return await this.instance.fetchUser(t);
+    }
+    async fetchUserById(t) {
+        return await this.instance.fetchUserById(t);
+    }
+    async updateUserById(t, e) {
+        return await this.instance.updateUserById(t, e);
+    }
+    async connectUser(t) {
+        return await this.instance.connectUser(t), this;
+    }
+    async chat(t, e) {
+        if (this.chats[t]) return this.chats[t];
+        {
+            const s = await this.instance.chat(t, e);
+            let a = null;
+            return s && ((a = new i(s)), (this.chats[t] = a)), a;
+        }
+    }
+    async groupChat(t) {
+        const e = await this.instance.groupChat(t);
+        let s = null;
+        return e && (s = new i(e)), s;
+    }
+}
+(exports.Chat = i),
+    (exports.MinChatProvider = function ({ apiKey: t, children: a, user: r, demo: i = !1, test: h = !1, socketOptions: u, onMessage: o }) {
+        const [d, g] = e.useState(),
+            [C, p] = e.useState(0),
+            [l, f] = e.useState(),
+            [m, M] = e.useState(),
+            [S, j] = e.useState();
+        return (
+            e.useEffect(() => {
+                (async () => {
+                    const e = c.getInstance(t).init({ test: h, demo: i, socketOptions: u });
+                    g(e);
+                })();
+            }, []),
+            e.useEffect(() => {
+                d &&
+                    r &&
+                    (async () => {
+                        await d.connectUser(r), j(d.instance.getConnectedUser());
+                    })();
+            }, [r, d]),
+            s.createElement(n.Provider, { value: { minChat: d, updateChatOrder: C, setUpdateChatOrder: p, chats: l, setChats: f, onMessage: o, user: S, onChatNewChat: m, setOnChatNewChat: M } }, a)
+        );
+    }),
+    (exports.default = c),
+    (exports.useChats = () => {
+        const [t, s] = e.useState(!0),
+            [a, c] = e.useState(),
+            [u, o] = e.useState(!0),
+            [d, g] = e.useState([]),
+            [C, p] = e.useState(1),
+            { updateChatOrder: l, chats: f, setChats: m, onMessage: M, onChatNewChat: S, setOnChatNewChat: j } = e.useContext(n),
+            [y, w] = e.useState(0),
+            I = h(),
+            T = r();
+        e.useEffect(() => {
+            f &&
+                S &&
+                (v(S.getLastMessage()),
+                m((t) => {
+                    let e;
+                    return (e = f.find((t) => t.getId() === S.getId()) ? (t ? t.map((t) => (t.getId() === S.getId() ? S : t)) : t) : t ? [S, ...t] : [S]), e ? U(e) : e;
+                }));
+        }, [S]);
+        const U = (t) =>
+            t.sort((t, e) => {
+                let s = null,
+                    a = null;
+                if ((t.jsChat.config.lastMessage && (s = t.jsChat.config.lastMessage.createdAt), e.jsChat.config.lastMessage && (a = e.jsChat.config.lastMessage.createdAt), s && a)) {
+                    const t = new Date(s);
+                    return new Date(a).getTime() - t.getTime();
+                }
+                return 0;
+            });
+        e.useEffect(() => {
+            f && (m((t) => (t ? U(t) : void 0)), w((t) => t + 1));
+        }, [f, l]),
+            e.useEffect(() => {
+                I &&
+                    T &&
+                    (x(),
+                    I.instance.onChat((t) => {
+                        const e = new i(t);
+                        j && j(e);
+                    }));
+            }, [I, T]);
+        const v = (t) => {
+                t && t.user.id !== (T && T.id) && M && M(t);
+            },
+            x = async () => {
+                if (I) {
+                    o(!0), c(void 0);
+                    const t = await I.instance.getChats(C);
+                    if ((p((t) => t + 1), !d.includes(t.page))) {
+                        g((e) => (e.push(t.page), e));
+                        const e = t.chats.map((t) => new i(t));
+                        m((t) => (t ? [...e, ...t] : e)), o(!1), s(!1);
+                    }
+                }
+            };
+        return { chats: f, loading: t, error: a, paginate: x, paginateLoading: u, chatsOrdered: y };
+    }),
+    (exports.useMessages = (t, s) => {
+        const [a, i] = e.useState(),
+            [h, c] = e.useState(!0),
+            [u, o] = e.useState(),
+            [d, g] = e.useState(!0),
+            C = r(),
+            { setUpdateChatOrder: p, setChats: l, chats: f, setOnChatNewChat: m } = e.useContext(n),
+            [M, S] = e.useState(1),
+            [j, y] = e.useState([]);
+        e.useEffect(() => {
+            if (f && a && t) {
+                l((e) => (e ? e.map((e) => (e.getId() === t.getId() && ("Group Chat" !== t.getTitle() ? e.setTitle(t.getTitle()) : t.setTitle(e.getTitle())), e)) : []));
+                for (const e of a) !e.seen && C && e.user.id !== C.id && t.jsChat.setSeen(e.id);
+            }
+        }, [a]),
+            e.useEffect(() => {
+                1 == M && 0 == j.length && I();
+            }, [M, j]),
+            e.useEffect(
+                () => (
+                    S(1),
+                    y([]),
+                    t &&
+                        (i(void 0),
+                        c(!0),
+                        g(!0),
+                        t.jsChat.onMessageSeen((t) => {
+                            i((e) => (e ? e.map((e) => (t === e.id ? { ...e, seen: !0 } : e)) : e));
+                        }),
+                        t.jsChat.onMessage((t) => {
+                            t ? (w(t), p((t) => t + 1)) : console.log("error");
+                        }),
+                        t.jsChat.onError((t) => {
+                            o(t);
+                        })),
+                    () => {
+                        t && t.release();
+                    }
+                ),
+                [t]
+            );
+        const w = (t) => {
+                i((e) => {
+                    const a = e ? [...e] : [];
+                    return s ? a.unshift(t) : a.push(t), a;
+                });
+            },
+            I = async () => {
+                g(!0), o(void 0);
+                let e = null;
+                t && (e = await t.jsChat.getMessages(M)),
+                    S((t) => t + 1),
+                    e &&
+                        !j.includes(e.page) &&
+                        (y((t) => (e && t.push(e.page), t)),
+                        i((t) => {
+                            const a =
+                                    t &&
+                                    t.map((t) => {
+                                        if (t.metadata && t.metadata.replacedWithServerData && e) for (const s of e.messages) if ((s.metadata && s.metadata.minchatMessageIdentifier) === t.metadata.minchatMessageIdentifier) return s;
+                                        return t;
+                                    }),
+                                n = new Set(a && a.map(({ id: t }) => t)),
+                                r = e && e.messages.filter((t) => !n.has(t.id));
+                            return r ? (a ? (s ? [...a, ...r.reverse()] : [...r, ...a]) : s ? r.reverse() : r) : a;
+                        }),
+                        c(!1)),
+                    g(!1);
+            };
+        return {
+            messages: a,
+            loading: h,
+            error: u,
+            paginate: I,
+            sendMessage: (e, s) => {
+                if (t) {
+                    m && m(t);
+                    const a = new Date(),
+                        n = a.toISOString(),
+                        r = e.metadata ? e.metadata : {};
+                    (r.minchatMessageIdentifier = n),
+                        C && w({ text: e.text, user: C, loading: !0, createdAt: a, id: n, metadata: { ...r, replacedWithServerData: "true" } }),
+                        t.jsChat.sendMessage({ ...e, metadata: r }, (t) => {
+                            t && i((e) => (e ? e.map((e) => ((e.metadata && e.metadata.minchatMessageIdentifier) === n ? t : e)) : e)), s && s(t);
+                        }),
+                        p((t) => t + 1);
+                }
+            },
+            paginateLoading: d,
+        };
+    }),
+    (exports.useMinChat = h),
+    (exports.useUser = r);
 //# sourceMappingURL=react.cjs.production.min.js.map
diff --git a/node_modules/@minchat/react/src/MinChatProvider.tsx b/node_modules/@minchat/react/src/MinChatProvider.tsx
index 4428094..dfa9f7a 100644
--- a/node_modules/@minchat/react/src/MinChatProvider.tsx
+++ b/node_modules/@minchat/react/src/MinChatProvider.tsx
@@ -57,6 +57,8 @@ export default function MinChatProvider({
 
     useEffect(() => {
         if (minchat && user) {
+            console.log('worl');
+            
             const updateConnectedUser = async () => {
                 await minchat.connectUser(user)
                 setContextUser(minchat.instance.getConnectedUser())
